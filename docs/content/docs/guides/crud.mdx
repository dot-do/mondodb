---
title: CRUD Operations
description: Create, Read, Update, and Delete documents in MondoDB
---

# CRUD Operations

MondoDB provides MongoDB-compatible CRUD (Create, Read, Update, Delete) operations for managing documents in your collections. This guide covers all available operations with examples.

## Quick Reference

| Operation | Method | Description |
|-----------|--------|-------------|
| **Create** | `insertOne()` | Insert a single document |
| | `insertMany()` | Insert multiple documents |
| **Read** | `findOne()` | Find a single document |
| | `find()` | Find multiple documents (returns cursor) |
| | `countDocuments()` | Count matching documents |
| | `estimatedDocumentCount()` | Fast count (metadata-based) |
| | `distinct()` | Get distinct values for a field |
| **Update** | `updateOne()` | Update a single document |
| | `updateMany()` | Update multiple documents |
| | `replaceOne()` | Replace a document entirely |
| | `findOneAndUpdate()` | Find and update atomically |
| | `findOneAndReplace()` | Find and replace atomically |
| **Delete** | `deleteOne()` | Delete a single document |
| | `deleteMany()` | Delete multiple documents |
| | `findOneAndDelete()` | Find and delete atomically |

## Create Operations

### insertOne

Insert a single document into a collection. If no `_id` is provided, one will be automatically generated.

```typescript
const result = await collection.insertOne({
  name: 'John Doe',
  email: 'john@example.com',
  age: 30,
  createdAt: new Date()
})

console.log(result)
// {
//   acknowledged: true,
//   insertedId: ObjectId("...")
// }
```

**Parameters:**
- `doc` - The document to insert
- `options` (optional) - Insert options
  - `session` - Client session for transaction support

**Returns:** `InsertOneResult`
- `acknowledged: boolean` - Whether the operation was acknowledged
- `insertedId: ObjectId` - The `_id` of the inserted document

### insertMany

Insert multiple documents into a collection.

```typescript
const result = await collection.insertMany([
  { name: 'Alice', email: 'alice@example.com', age: 25 },
  { name: 'Bob', email: 'bob@example.com', age: 35 },
  { name: 'Carol', email: 'carol@example.com', age: 28 }
])

console.log(result)
// {
//   acknowledged: true,
//   insertedCount: 3,
//   insertedIds: {
//     0: ObjectId("..."),
//     1: ObjectId("..."),
//     2: ObjectId("...")
//   }
// }
```

**Parameters:**
- `docs` - Array of documents to insert
- `options` (optional) - Insert options

**Returns:** `InsertManyResult`
- `acknowledged: boolean` - Whether the operation was acknowledged
- `insertedCount: number` - Number of documents inserted
- `insertedIds: Record<number, ObjectId>` - Map of index to inserted `_id`

---

## Read Operations

### findOne

Find a single document matching the filter. Returns `null` if no document matches.

```typescript
// Find by field value
const user = await collection.findOne({ email: 'john@example.com' })

// Find by _id
const userById = await collection.findOne({ _id: someObjectId })

// With projection (select specific fields)
const userWithProjection = await collection.findOne(
  { email: 'john@example.com' },
  { projection: { name: 1, email: 1 } }
)
```

**Parameters:**
- `filter` - Query filter (see [Filter Operators](#filter-operators))
- `options` (optional) - Find options
  - `projection` - Fields to include (1) or exclude (0)
  - `sort` - Sort order for determining which document to return
  - `skip` - Number of documents to skip
  - `limit` - Maximum number of documents to consider

**Returns:** The matching document or `null`

### find

Find all documents matching the filter. Returns a cursor for lazy evaluation.

```typescript
// Basic find with toArray
const users = await collection.find({ age: { $gte: 25 } }).toArray()

// Using async iterator
for await (const user of collection.find({ status: 'active' })) {
  console.log(user.name)
}

// Chainable cursor methods
const results = await collection.find({})
  .sort({ name: 1 })        // Sort ascending by name
  .skip(10)                  // Skip first 10 documents
  .limit(5)                  // Return only 5 documents
  .project({ name: 1 })      // Only include name field
  .toArray()
```

**Cursor Methods:**
- `sort(spec)` - Set sort order: `{ field: 1 }` (ascending) or `{ field: -1 }` (descending)
- `limit(count)` - Maximum documents to return
- `skip(count)` - Number of documents to skip
- `project(spec)` - Fields to include/exclude
- `toArray()` - Execute query and return all documents as array
- `forEach(callback)` - Execute callback for each document
- `count()` - Count matching documents
- `hasNext()` - Check if more documents exist
- `next()` - Get next document
- `map(fn)` - Transform documents

---

## Filter Operators

MondoDB supports standard MongoDB query operators:

### Comparison Operators

```typescript
// Equality
{ status: 'active' }
{ status: { $eq: 'active' } }

// Not equal
{ status: { $ne: 'inactive' } }

// Greater than / Greater than or equal
{ age: { $gt: 25 } }
{ age: { $gte: 25 } }

// Less than / Less than or equal
{ age: { $lt: 50 } }
{ age: { $lte: 50 } }

// In array of values
{ status: { $in: ['active', 'pending'] } }

// Not in array
{ status: { $nin: ['deleted', 'archived'] } }
```

### Logical Operators

```typescript
// AND - all conditions must match
{ $and: [{ age: { $gte: 25 } }, { status: 'active' }] }

// OR - at least one condition must match
{ $or: [{ status: 'active' }, { priority: 'high' }] }

// NOR - none of the conditions can match
{ $nor: [{ status: 'deleted' }, { status: 'archived' }] }

// NOT - negate a condition
{ age: { $not: { $lt: 25 } } }
```

### Element Operators

```typescript
// Field exists
{ email: { $exists: true } }

// Field type
{ age: { $type: 'number' } }
```

### Array Operators

```typescript
// Array contains value
{ tags: 'mongodb' }

// Array contains all values
{ tags: { $all: ['mongodb', 'database'] } }

// Array size
{ tags: { $size: 3 } }

// Element match (for arrays of objects)
{ items: { $elemMatch: { qty: { $gt: 5 }, price: { $lt: 10 } } } }
```

### String Operators

```typescript
// Regular expression match
{ name: { $regex: '^John' } }
{ email: { $regex: '@example\\.com$' } }
```

### Dot Notation

Access nested fields using dot notation:

```typescript
// Match nested field
{ 'address.city': 'New York' }

// With operators
{ 'address.zipcode': { $regex: '^100' } }
```

---

## Update Operations

### updateOne

Update a single document matching the filter.

```typescript
const result = await collection.updateOne(
  { email: 'john@example.com' },
  { $set: { age: 31, updatedAt: new Date() } }
)

console.log(result)
// {
//   acknowledged: true,
//   matchedCount: 1,
//   modifiedCount: 1
// }
```

**Parameters:**
- `filter` - Query filter to find the document
- `update` - Update operations (see [Update Operators](#update-operators))
- `options` (optional) - Update options
  - `upsert` - Insert if no document matches (default: `false`)
  - `arrayFilters` - Filters for array update operations

**Returns:** `UpdateResult`
- `matchedCount: number` - Number of documents matched
- `modifiedCount: number` - Number of documents modified
- `upsertedId?: ObjectId` - The `_id` if upserted
- `upsertedCount?: number` - 1 if upserted, otherwise 0

### updateMany

Update all documents matching the filter.

```typescript
const result = await collection.updateMany(
  { status: 'pending' },
  { $set: { status: 'processed', processedAt: new Date() } }
)

console.log(result)
// {
//   acknowledged: true,
//   matchedCount: 15,
//   modifiedCount: 15
// }
```

### Upsert

When `upsert: true`, the operation inserts a new document if no match is found:

```typescript
const result = await collection.updateOne(
  { email: 'new@example.com' },
  { $set: { name: 'New User', createdAt: new Date() } },
  { upsert: true }
)

// If no document matched, a new one is created
if (result.upsertedId) {
  console.log('Created new document:', result.upsertedId)
}
```

---

## Update Operators

### Field Operators

```typescript
// $set - Set field values
{ $set: { name: 'Jane', age: 30 } }

// $unset - Remove fields
{ $unset: { temporaryField: '' } }

// $inc - Increment numeric values
{ $inc: { views: 1, score: 5 } }

// $mul - Multiply numeric values
{ $mul: { price: 1.1 } }  // Increase by 10%

// $min - Update if new value is less than current
{ $min: { lowScore: 50 } }

// $max - Update if new value is greater than current
{ $max: { highScore: 100 } }

// $rename - Rename a field
{ $rename: { oldFieldName: 'newFieldName' } }

// $currentDate - Set to current date
{ $currentDate: { lastModified: true } }
{ $currentDate: { lastModified: { $type: 'timestamp' } } }
```

### Array Operators

```typescript
// $push - Add element to array
{ $push: { tags: 'new-tag' } }

// $push with $each - Add multiple elements
{ $push: { tags: { $each: ['tag1', 'tag2', 'tag3'] } } }

// $addToSet - Add only if not exists
{ $addToSet: { tags: 'unique-tag' } }

// $addToSet with $each
{ $addToSet: { tags: { $each: ['tag1', 'tag2'] } } }

// $pull - Remove matching elements
{ $pull: { tags: 'remove-me' } }

// $pop - Remove first or last element
{ $pop: { tags: 1 } }   // Remove last
{ $pop: { tags: -1 } }  // Remove first
```

### Nested Field Updates

```typescript
// Update nested field
{ $set: { 'address.city': 'Los Angeles' } }

// Update array element by index
{ $set: { 'items.0.qty': 10 } }
```

---

## Replace Operation

### replaceOne

Replace an entire document (preserves `_id`).

```typescript
const result = await collection.replaceOne(
  { _id: someObjectId },
  {
    name: 'Complete Replacement',
    email: 'replaced@example.com',
    status: 'new'
    // Note: This replaces ALL fields except _id
  }
)

console.log(result)
// {
//   acknowledged: true,
//   matchedCount: 1,
//   modifiedCount: 1
// }
```

**Parameters:**
- `filter` - Query filter to find the document
- `replacement` - The replacement document (must not contain update operators)
- `options` (optional) - Replace options
  - `upsert` - Insert if no document matches

---

## Delete Operations

### deleteOne

Delete a single document matching the filter.

```typescript
const result = await collection.deleteOne({ email: 'john@example.com' })

console.log(result)
// {
//   acknowledged: true,
//   deletedCount: 1
// }
```

**Parameters:**
- `filter` - Query filter
- `options` (optional) - Delete options

**Returns:** `DeleteResult`
- `acknowledged: boolean` - Whether the operation was acknowledged
- `deletedCount: number` - Number of documents deleted

### deleteMany

Delete all documents matching the filter.

```typescript
// Delete all inactive users
const result = await collection.deleteMany({ status: 'inactive' })

console.log(result)
// {
//   acknowledged: true,
//   deletedCount: 42
// }

// Delete all documents (empty filter)
const clearResult = await collection.deleteMany({})
```

---

## Find-and-Modify Operations

These operations atomically find and modify documents, returning the document before or after the modification.

### findOneAndUpdate

Find a document and update it, returning the document.

```typescript
// Return document AFTER update
const updated = await collection.findOneAndUpdate(
  { email: 'john@example.com' },
  { $inc: { loginCount: 1 }, $set: { lastLogin: new Date() } },
  { returnDocument: 'after' }
)

// Return document BEFORE update (default)
const original = await collection.findOneAndUpdate(
  { email: 'john@example.com' },
  { $set: { status: 'active' } },
  { returnDocument: 'before' }
)

// With sort (update first matching after sort)
const newest = await collection.findOneAndUpdate(
  { status: 'pending' },
  { $set: { status: 'processing' } },
  { sort: { createdAt: -1 }, returnDocument: 'after' }
)

// With upsert
const upserted = await collection.findOneAndUpdate(
  { email: 'new@example.com' },
  { $set: { name: 'New User' } },
  { upsert: true, returnDocument: 'after' }
)
```

**Options:**
- `projection` - Fields to include/exclude in returned document
- `sort` - Sort order for determining which document to update
- `upsert` - Insert if no document matches
- `returnDocument` - Return `'before'` (default) or `'after'` modification

### findOneAndDelete

Find a document and delete it, returning the deleted document.

```typescript
const deleted = await collection.findOneAndDelete(
  { status: 'expired' },
  { sort: { expiresAt: 1 } }  // Delete oldest expired first
)

if (deleted) {
  console.log('Deleted:', deleted.name)
}
```

**Options:**
- `projection` - Fields to include/exclude in returned document
- `sort` - Sort order for determining which document to delete

### findOneAndReplace

Find a document and replace it, returning the document.

```typescript
const replaced = await collection.findOneAndReplace(
  { _id: someObjectId },
  {
    name: 'Replaced Document',
    email: 'replaced@example.com',
    version: 2
  },
  { returnDocument: 'after' }
)
```

**Options:**
- `projection` - Fields to include/exclude in returned document
- `sort` - Sort order for determining which document to replace
- `upsert` - Insert if no document matches
- `returnDocument` - Return `'before'` (default) or `'after'` replacement

---

## Counting Documents

### countDocuments

Count documents matching a filter. This method performs an exact count by querying the documents.

```typescript
const count = await collection.countDocuments({ status: 'active' })
console.log(`Active users: ${count}`)

// Count all documents
const total = await collection.countDocuments({})

// Count with complex filter
const recentActiveCount = await collection.countDocuments({
  status: 'active',
  createdAt: { $gte: new Date('2024-01-01') }
})
```

**Parameters:**
- `filter` (optional) - Query filter (defaults to `{}` for all documents)

**Returns:** `Promise<number>` - The number of matching documents

### estimatedDocumentCount

Get an estimated count of documents in the collection. This method is faster than `countDocuments()` as it uses collection metadata rather than scanning documents.

```typescript
// Fast count using collection metadata
const estimatedCount = await collection.estimatedDocumentCount()
console.log(`Approximately ${estimatedCount} documents in collection`)
```

**Note:** This count may not be perfectly accurate if there are ongoing writes to the collection. Use `countDocuments()` when you need an exact count.

**Returns:** `Promise<number>` - The estimated number of documents

### distinct

Get distinct (unique) values for a specified field across all documents.

```typescript
// Get all unique status values
const statuses = await collection.distinct('status')
console.log(statuses)
// ['active', 'inactive', 'pending']

// Get distinct values with a filter
const activeCategories = await collection.distinct('category', { status: 'active' })
console.log(activeCategories)
// ['electronics', 'clothing', 'food']

// Get distinct nested field values
const cities = await collection.distinct('address.city')
```

**Parameters:**
- `field` - The field name to get distinct values for
- `filter` (optional) - Query filter to limit which documents are considered

**Returns:** `Promise<T[]>` - Array of distinct values

**TypeScript Usage:**
```typescript
// With type parameter for type safety
const ages = await collection.distinct<number>('age')
const names = await collection.distinct<string>('name', { status: 'active' })
```

---

## Projection

Control which fields are returned in query results.

### Include Fields

```typescript
// Only return name and email
const users = await collection.find(
  { status: 'active' },
  { projection: { name: 1, email: 1 } }
).toArray()

// Result: [{ _id: ..., name: 'John', email: 'john@...' }, ...]
```

### Exclude Fields

```typescript
// Return all fields except password
const users = await collection.find(
  { status: 'active' },
  { projection: { password: 0, secret: 0 } }
).toArray()
```

### Exclude _id

```typescript
// Return name and email without _id
const users = await collection.find(
  { status: 'active' },
  { projection: { _id: 0, name: 1, email: 1 } }
).toArray()

// Result: [{ name: 'John', email: 'john@...' }, ...]
```

---

## Error Handling

### Duplicate Key Error

When inserting a document with an `_id` that already exists:

```typescript
try {
  await collection.insertOne({ _id: existingId, name: 'Duplicate' })
} catch (error) {
  if (error.code === 11000) {
    console.log('Document with this _id already exists')
  }
}
```

---

## Transaction Support

CRUD operations can be executed within transactions using sessions:

```typescript
const session = client.startSession()

try {
  session.startTransaction()

  await collection.insertOne({ name: 'User 1' }, { session })
  await collection.updateOne(
    { name: 'User 2' },
    { $inc: { balance: -100 } },
    { session }
  )

  await session.commitTransaction()
} catch (error) {
  await session.abortTransaction()
  throw error
} finally {
  session.endSession()
}
```

See the [Transactions Guide](/docs/guides/transactions) for more details.

---

## TypeScript Type Definitions

MondoDB provides full TypeScript support with typed collections and results.

### Typed Collections

```typescript
// Define your document schema
interface User {
  _id?: ObjectId
  name: string
  email: string
  age: number
  status: 'active' | 'inactive'
  createdAt: Date
}

// Create a typed collection
const users = db.collection<User>('users')

// TypeScript will enforce correct types
await users.insertOne({
  name: 'John',
  email: 'john@example.com',
  age: 30,
  status: 'active',
  createdAt: new Date()
})

// Type-safe queries
const user = await users.findOne({ email: 'john@example.com' })
// user is typed as (User & { _id: ObjectId }) | null
```

### Result Types

```typescript
// InsertOneResult
interface InsertOneResult {
  acknowledged: boolean
  insertedId: ObjectId
}

// InsertManyResult
interface InsertManyResult {
  acknowledged: boolean
  insertedCount: number
  insertedIds: Record<number, ObjectId>
}

// UpdateResult
interface UpdateResult {
  acknowledged: boolean
  matchedCount: number
  modifiedCount: number
  upsertedId?: ObjectId
  upsertedCount?: number
}

// DeleteResult
interface DeleteResult {
  acknowledged: boolean
  deletedCount: number
}
```

### Filter Types

```typescript
// Filters are type-safe based on your document schema
const filter: Filter<User> = {
  age: { $gte: 25 },
  status: 'active'  // TypeScript knows this must be 'active' | 'inactive'
}

// Update operations are also typed
const update: UpdateFilter<User> = {
  $set: { status: 'inactive' },
  $inc: { age: 1 }
}
```

---

## Collection Management

### drop

Drop (delete) the entire collection and all its documents.

```typescript
await collection.drop()
```

**Warning:** This operation is irreversible and deletes all data in the collection.

---

## Aggregation

For complex queries involving grouping, transformations, and multi-stage processing, see the [Aggregation Guide](/docs/guides/aggregation).

```typescript
// Simple aggregation example
const results = await collection.aggregate([
  { $match: { status: 'active' } },
  { $group: { _id: '$category', count: { $sum: 1 } } },
  { $sort: { count: -1 } }
]).toArray()
```

---

## Related Guides

- [Query & Filter Syntax](/docs/guides/queries) - Complete guide to query operators
- [Bulk Write Operations](/docs/guides/bulk-write) - Batch multiple operations
- [Aggregation Pipeline](/docs/guides/aggregation) - Complex data transformations
- [Cursors](/docs/guides/cursors) - Working with query cursors
- [Transactions](/docs/guides/transactions) - Multi-document transactions
- [Indexing](/docs/guides/indexing) - Improve query performance
