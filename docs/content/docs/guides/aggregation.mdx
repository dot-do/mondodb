---
title: Aggregation Pipeline
description: Comprehensive guide to MongoDB-style aggregation pipelines in MondoDB
---

# Aggregation Pipeline

MondoDB supports MongoDB's aggregation pipeline framework, allowing you to process and transform documents through a series of stages. The aggregation framework translates MongoDB pipeline syntax to optimized SQL queries executed against SQLite, providing familiar MongoDB semantics with the reliability of SQL.

## Basic Usage

Use the `aggregate()` method on a collection to execute an aggregation pipeline:

```typescript
const results = await collection.aggregate([
  { $match: { status: 'active' } },
  { $group: { _id: '$category', count: { $sum: 1 } } },
  { $sort: { count: -1 } }
]).toArray();
```

The `aggregate()` method returns a cursor that supports:
- Async iteration with `for await (const doc of cursor)`
- Converting to array with `await cursor.toArray()`
- forEach iteration with `await cursor.forEach(callback)`

## Supported Pipeline Stages

MondoDB supports the following aggregation pipeline stages:

| Stage | Description |
|-------|-------------|
| [`$match`](#match) | Filters documents based on conditions |
| [`$project`](#project) | Reshapes documents by including, excluding, or computing fields |
| [`$group`](#group) | Groups documents by a key and applies accumulators |
| [`$sort`](#sort) | Sorts documents by specified fields |
| [`$limit`](#limit) | Limits the number of documents |
| [`$skip`](#skip) | Skips a number of documents |
| [`$count`](#count) | Counts documents and returns the count |
| [`$addFields`](#addfields) | Adds new fields to documents |
| [`$set`](#addfields) | Alias for `$addFields` |
| [`$lookup`](#lookup) | Performs a left outer join with another collection |
| [`$unwind`](#unwind) | Deconstructs an array field into multiple documents |
| [`$bucket`](#bucket) | Categorizes documents into buckets |
| [`$facet`](#facet) | Processes multiple pipelines in a single stage |
| [`$search`](#search) | Full-text search (Atlas Search compatible) |
| [`$vectorSearch`](#vectorsearch) | Vector similarity search |

---

## $match

Filters documents to pass only those that match the specified condition(s). This stage translates to a SQL `WHERE` clause.

```typescript
// Simple match
await collection.aggregate([
  { $match: { status: 'active' } }
]).toArray();

// Match with comparison operators
await collection.aggregate([
  { $match: { age: { $gte: 18, $lte: 65 } } }
]).toArray();

// Match with logical operators
await collection.aggregate([
  {
    $match: {
      $or: [
        { status: 'active' },
        { priority: 'high' }
      ]
    }
  }
]).toArray();
```

### Supported Query Operators in $match

**Comparison Operators:**
| Operator | Description | SQL Translation |
|----------|-------------|-----------------|
| `$eq` | Equal | `=` |
| `$ne` | Not equal | `!=` |
| `$gt` | Greater than | `>` |
| `$gte` | Greater than or equal | `>=` |
| `$lt` | Less than | `<` |
| `$lte` | Less than or equal | `<=` |
| `$in` | Match any value in array | `IN (...)` |
| `$nin` | Match none in array | `NOT IN (...)` |
| `$regex` | Regular expression matching | `LIKE` pattern |
| `$mod` | Modulo operation | `% operator` |

**Logical Operators:**
| Operator | Description | SQL Translation |
|----------|-------------|-----------------|
| `$and` | Logical AND | `AND` |
| `$or` | Logical OR | `OR` |
| `$nor` | Logical NOR | `NOT (... OR ...)` |
| `$not` | Logical NOT | `NOT (...)` |

**Element Operators:**
| Operator | Description | SQL Translation |
|----------|-------------|-----------------|
| `$exists` | Check if field exists | `json_type(...) IS [NOT] NULL` |
| `$type` | Check field type | `json_type(...) = 'type'` |

**Array Operators:**
| Operator | Description | SQL Translation |
|----------|-------------|-----------------|
| `$all` | Match arrays containing all elements | `EXISTS` with `json_each` |
| `$elemMatch` | Match arrays with element conditions | `EXISTS` subquery |
| `$size` | Match arrays of specific size | `json_array_length(...)` |

### $match Examples

```typescript
// Complex query with multiple conditions
await collection.aggregate([
  {
    $match: {
      $and: [
        { category: { $in: ['electronics', 'books'] } },
        { price: { $gte: 10, $lte: 100 } },
        { inStock: { $exists: true } },
        { tags: { $all: ['sale', 'featured'] } }
      ]
    }
  }
]).toArray();

// Regex matching (case-insensitive)
await collection.aggregate([
  {
    $match: {
      name: { $regex: '^john', $options: 'i' }
    }
  }
]).toArray();

// Array element matching
await collection.aggregate([
  {
    $match: {
      scores: {
        $elemMatch: { $gte: 80, $lte: 100 }
      }
    }
  }
]).toArray();
```

---

## $project

Reshapes documents by including, excluding, or computing new fields. Translates to SQL `SELECT` with `json_object()` or `json_remove()`.

### Inclusion Projection

Include specific fields (value of `1`):

```typescript
await collection.aggregate([
  { $project: { name: 1, email: 1, _id: 0 } }
]).toArray();
```

### Exclusion Projection

Exclude specific fields (value of `0`):

```typescript
await collection.aggregate([
  { $project: { password: 0, sensitiveData: 0 } }
]).toArray();
```

Note: You cannot mix inclusion and exclusion in the same projection (except for `_id`).

### Field Renaming

Use field references (starting with `$`) to rename fields:

```typescript
await collection.aggregate([
  { $project: {
    username: '$name',
    userEmail: '$email',
    address: '$contact.address'  // Nested field reference
  } }
]).toArray();
```

### Computed Fields

Use expression operators to compute new field values:

```typescript
await collection.aggregate([
  { $project: {
    name: 1,
    totalPrice: { $multiply: ['$price', '$quantity'] },
    discountedPrice: { $subtract: ['$price', '$discount'] },
    fullName: { $concat: ['$firstName', ' ', '$lastName'] }
  } }
]).toArray();
```

### Conditional Fields

Use `$cond` for if/then/else logic:

```typescript
await collection.aggregate([
  { $project: {
    name: 1,
    status: {
      $cond: {
        if: { $gte: ['$score', 70] },
        then: 'pass',
        else: 'fail'
      }
    },
    // Array shorthand: [condition, trueValue, falseValue]
    grade: { $cond: [{ $gte: ['$score', 90] }, 'A', 'B'] }
  } }
]).toArray();
```

---

## $group

Groups documents by a specified expression and applies accumulator expressions. Translates to SQL `GROUP BY` with aggregate functions.

### Group by Single Field

```typescript
await collection.aggregate([
  { $group: {
    _id: '$category',
    count: { $sum: 1 },
    totalRevenue: { $sum: '$price' }
  } }
]).toArray();
```

### Group by Multiple Fields (Compound _id)

```typescript
await collection.aggregate([
  { $group: {
    _id: {
      year: '$year',
      month: '$month',
      region: '$region'
    },
    totalSales: { $sum: '$amount' },
    averageOrder: { $avg: '$amount' }
  } }
]).toArray();
```

### Total Aggregation (null _id)

Use `null` as `_id` to aggregate across all documents:

```typescript
await collection.aggregate([
  { $group: {
    _id: null,
    totalDocuments: { $sum: 1 },
    averagePrice: { $avg: '$price' },
    minPrice: { $min: '$price' },
    maxPrice: { $max: '$price' }
  } }
]).toArray();
```

### Supported Accumulator Operators

| Operator | Description | SQL Translation |
|----------|-------------|-----------------|
| `$sum` | Sum values or count with `$sum: 1` | `SUM()` |
| `$avg` | Calculate average | `AVG()` |
| `$min` | Find minimum value | `MIN()` |
| `$max` | Find maximum value | `MAX()` |
| `$first` | First value in group | Subquery with `LIMIT 1` |
| `$last` | Last value in group | Subquery with `ORDER BY ... DESC LIMIT 1` |
| `$push` | Collect all values into array | `json_group_array()` |
| `$addToSet` | Collect unique values into array | `json_group_array(DISTINCT ...)` |
| `$count` | Count documents | `COUNT(*)` |

### Using Multiple Accumulators

```typescript
await collection.aggregate([
  { $group: {
    _id: '$department',
    employeeCount: { $sum: 1 },
    avgSalary: { $avg: '$salary' },
    minSalary: { $min: '$salary' },
    maxSalary: { $max: '$salary' },
    totalPayroll: { $sum: '$salary' },
    employees: { $push: '$name' },
    uniqueRoles: { $addToSet: '$role' },
    firstHired: { $first: '$hireDate' },
    lastHired: { $last: '$hireDate' }
  } }
]).toArray();
```

---

## $sort

Sorts documents by the specified field(s). Translates to SQL `ORDER BY`.

```typescript
// Ascending sort (1)
await collection.aggregate([
  { $sort: { name: 1 } }
]).toArray();

// Descending sort (-1)
await collection.aggregate([
  { $sort: { createdAt: -1 } }
]).toArray();

// Multiple sort fields (applied in order)
await collection.aggregate([
  { $sort: { category: 1, price: -1, name: 1 } }
]).toArray();
```

### Sort with Nested Fields

```typescript
await collection.aggregate([
  { $sort: { 'address.city': 1, 'address.street': 1 } }
]).toArray();
```

---

## $limit

Limits the number of documents passed to the next stage. Translates to SQL `LIMIT`.

```typescript
// Get top 10 documents
await collection.aggregate([
  { $sort: { score: -1 } },
  { $limit: 10 }
]).toArray();
```

---

## $skip

Skips the specified number of documents. Translates to SQL `OFFSET`.

```typescript
// Skip first 20 documents
await collection.aggregate([
  { $skip: 20 }
]).toArray();
```

### Pagination Pattern

```typescript
const page = 2;
const pageSize = 10;

await collection.aggregate([
  { $match: { status: 'published' } },
  { $sort: { createdAt: -1 } },
  { $skip: (page - 1) * pageSize },
  { $limit: pageSize }
]).toArray();
```

---

## $count

Counts the number of documents and returns a single document with the count.

```typescript
const result = await collection.aggregate([
  { $match: { status: 'active' } },
  { $count: 'activeCount' }
]).toArray();
// Returns: [{ activeCount: 42 }]
```

---

## $addFields

Adds new fields to documents without removing existing fields. The `$set` stage is an alias for `$addFields`. Uses SQL `json_set()` for the transformation.

```typescript
// Add computed fields
await collection.aggregate([
  { $addFields: {
    fullName: { $concat: ['$firstName', ' ', '$lastName'] },
    totalValue: { $multiply: ['$price', '$quantity'] },
    isExpensive: { $gte: ['$price', 100] }
  } }
]).toArray();

// Using $set (alias for $addFields)
await collection.aggregate([
  { $set: {
    lastModified: new Date().toISOString(),
    isActive: true,
    score: { $add: ['$baseScore', '$bonusPoints'] }
  } }
]).toArray();
```

### Overwrite Existing Fields

```typescript
await collection.aggregate([
  { $addFields: {
    // Overwrite price with discounted price
    price: { $multiply: ['$price', 0.9] },
    // Add new field
    hasDiscount: true
  } }
]).toArray();
```

### Add Literal Values

```typescript
await collection.aggregate([
  { $addFields: {
    stringField: 'literal string',
    numberField: 42,
    booleanField: true,
    arrayField: [1, 2, 3],
    nullField: null
  } }
]).toArray();
```

---

## $lookup

Performs a left outer join with another collection. Supports both simple and pipeline-based lookups.

### Simple Lookup

Join collections using matching field values:

```typescript
await collection.aggregate([
  { $lookup: {
    from: 'orders',           // Foreign collection
    localField: 'customerId', // Field in current collection
    foreignField: 'customerId', // Field in foreign collection
    as: 'customerOrders'      // Output array field name
  } }
]).toArray();
```

This translates to a SQL subquery using `json_group_array()`:

```sql
SELECT
  documents.data,
  COALESCE(
    (SELECT json_group_array(orders.data)
     FROM orders
     WHERE json_extract(orders.data, '$.customerId') =
           json_extract(documents.data, '$.customerId')),
    '[]'
  ) AS lookup_result
FROM documents
```

### Pipeline Lookup (Advanced)

Use a sub-pipeline for more complex joins with variable binding:

```typescript
await collection.aggregate([
  { $lookup: {
    from: 'orders',
    let: { custId: '$_id' },
    pipeline: [
      { $match: { status: 'completed' } }
    ],
    as: 'completedOrders'
  } }
]).toArray();
```

### Lookup with Unwind

Common pattern to flatten lookup results:

```typescript
await collection.aggregate([
  { $lookup: {
    from: 'authors',
    localField: 'authorId',
    foreignField: '_id',
    as: 'author'
  } },
  { $unwind: '$author' },
  { $project: {
    title: 1,
    authorName: '$author.name'
  } }
]).toArray();
```

---

## $unwind

Deconstructs an array field, outputting one document for each element. Uses SQL `json_each()` for array expansion.

### Basic Unwind

```typescript
// Input: { name: 'Product', tags: ['sale', 'new', 'featured'] }
await collection.aggregate([
  { $unwind: '$tags' }
]).toArray();
// Output: 3 documents, each with a single tag value
```

### Unwind with Options

```typescript
await collection.aggregate([
  { $unwind: {
    path: '$items',
    includeArrayIndex: 'itemIndex',      // Add index as field
    preserveNullAndEmptyArrays: true     // Keep docs with null/empty arrays
  } }
]).toArray();
```

### Unwind Options

| Option | Type | Description |
|--------|------|-------------|
| `path` | string | The array field path to unwind (required, starts with `$`) |
| `includeArrayIndex` | string | Field name to store the array element index |
| `preserveNullAndEmptyArrays` | boolean | If `true`, output document even if array is null/empty/missing |

### Unwind for Aggregation

```typescript
// Count occurrences of each tag
await collection.aggregate([
  { $unwind: '$tags' },
  { $group: {
    _id: '$tags',
    count: { $sum: 1 }
  } },
  { $sort: { count: -1 } }
]).toArray();
```

---

## $bucket

Categorizes documents into groups (buckets) based on a specified expression and boundaries. Uses SQL `CASE WHEN` for bucket assignment.

```typescript
// Bucket products by price ranges
await collection.aggregate([
  { $bucket: {
    groupBy: '$price',
    boundaries: [0, 50, 100, 200, 500],
    default: 'Other',
    output: {
      count: { $sum: 1 },
      products: { $push: '$name' },
      avgPrice: { $avg: '$price' }
    }
  } }
]).toArray();
// Returns buckets: 0-50, 50-100, 100-200, 200-500, Other
```

### Bucket Options

| Option | Type | Description |
|--------|------|-------------|
| `groupBy` | string | Field path or expression to group on |
| `boundaries` | number[] | Array of boundary values (must be sorted) |
| `default` | string | Bucket name for values outside boundaries |
| `output` | object | Accumulator expressions for each bucket |

### Bucket Output Accumulators

The `output` option supports these accumulators:

| Accumulator | Description |
|-------------|-------------|
| `$sum` | Sum values or count documents |
| `$avg` | Calculate average |
| `$min` | Find minimum |
| `$max` | Find maximum |
| `$push` | Collect values into array |
| `$count` | Count documents |

---

## $facet

Processes multiple aggregation pipelines within a single stage. Each sub-pipeline operates independently on the same input documents.

```typescript
await collection.aggregate([
  { $facet: {
    // Count by category
    categoryCounts: [
      { $group: { _id: '$category', count: { $sum: 1 } } },
      { $sort: { count: -1 } }
    ],
    // Calculate price statistics
    priceStats: [
      { $group: {
        _id: null,
        avgPrice: { $avg: '$price' },
        minPrice: { $min: '$price' },
        maxPrice: { $max: '$price' }
      } }
    ],
    // Get top 5 products
    topProducts: [
      { $sort: { sales: -1 } },
      { $limit: 5 },
      { $project: { name: 1, sales: 1 } }
    ]
  } }
]).toArray();
// Returns: [{ categoryCounts: [...], priceStats: [...], topProducts: [...] }]
```

### Facet Use Cases

- **Dashboard data**: Fetch multiple metrics in one query
- **Search with filters**: Return results and facet counts together
- **Statistics**: Calculate different aggregations on the same data

---

## $search

Performs full-text search using SQLite FTS5. Must be the first stage in a pipeline.

### Text Search

```typescript
await collection.aggregate([
  { $search: {
    text: {
      query: 'mongodb database',
      path: 'description'
    }
  } }
]).toArray();
```

### Phrase Search

```typescript
await collection.aggregate([
  { $search: {
    phrase: {
      query: 'exact phrase match',
      path: 'content'
    }
  } }
]).toArray();
```

### Wildcard Search

```typescript
await collection.aggregate([
  { $search: {
    wildcard: {
      query: 'data*',
      path: 'content'
    }
  } }
]).toArray();
```

### Autocomplete Search

```typescript
await collection.aggregate([
  { $search: {
    autocomplete: {
      query: 'mach',
      path: 'title',
      tokenOrder: 'sequential'  // or 'any'
    }
  } }
]).toArray();
```

### Compound Search

Combine multiple search conditions:

```typescript
await collection.aggregate([
  { $search: {
    compound: {
      must: [
        { text: { query: 'required term', path: 'title' } }
      ],
      should: [
        { text: { query: 'optional boost', path: 'description' } }
      ],
      mustNot: [
        { text: { query: 'excluded', path: 'tags' } }
      ],
      filter: [
        { text: { query: 'category filter', path: 'category' } }
      ]
    }
  } }
]).toArray();
```

### Search Operators

| Operator | Description |
|----------|-------------|
| `text` | Full-text search on specified fields |
| `phrase` | Exact phrase matching |
| `wildcard` | Wildcard pattern matching (suffix `*`) |
| `autocomplete` | Prefix matching for autocomplete |
| `compound` | Boolean combinations (must, should, mustNot, filter) |

---

## $vectorSearch

Performs vector similarity search using Cloudflare Vectorize. Must be the first stage in a pipeline.

```typescript
await collection.aggregate([
  { $vectorSearch: {
    index: 'vector_index',
    path: 'embedding',
    queryVector: [0.1, 0.2, 0.3, ...], // Your query vector
    numCandidates: 100,
    limit: 10
  } }
]).toArray();
```

### Vector Search with Filter

```typescript
await collection.aggregate([
  { $vectorSearch: {
    index: 'vector_index',
    path: 'embedding',
    queryVector: queryEmbedding,
    numCandidates: 200,
    limit: 20,
    filter: { category: 'technology' }
  } },
  { $project: {
    title: 1,
    score: { $meta: 'vectorSearchScore' }
  } }
]).toArray();
```

### Vector Search Options

| Option | Type | Description |
|--------|------|-------------|
| `index` | string | Name of the vector search index |
| `path` | string | Path to the vector field in documents |
| `queryVector` | number[] | The query vector for similarity search |
| `numCandidates` | number | Number of candidates to consider (default: limit * 10) |
| `limit` | number | Maximum number of results to return |
| `filter` | object | Optional pre-filter before vector search |
| `exact` | boolean | If true, performs exact search (slower but more accurate) |
| `scoreField` | string | Field name to store similarity score (default: 'score') |

---

## Expression Operators

Expression operators can be used within stages like `$project`, `$addFields`, `$group`, and `$bucket`. See the [Aggregation Operators Reference](/docs/reference/aggregation-operators) for complete documentation.

### Quick Reference

**Arithmetic:**
```typescript
{ $add: ['$a', '$b'] }           // a + b
{ $subtract: ['$a', '$b'] }      // a - b
{ $multiply: ['$a', '$b'] }      // a * b
{ $divide: ['$a', '$b'] }        // a / b
{ $mod: ['$a', '$b'] }           // a % b
```

**String:**
```typescript
{ $concat: ['$first', ' ', '$last'] }  // Concatenation
{ $substr: ['$str', 0, 10] }           // Substring
{ $toLower: '$email' }                  // Lowercase
{ $toUpper: '$code' }                   // Uppercase
```

**Conditional:**
```typescript
{ $cond: { if: expr, then: val1, else: val2 } }
{ $cond: [expr, val1, val2] }  // Array shorthand
{ $ifNull: ['$field', 'default'] }
{ $switch: { branches: [...], default: val } }
```

**Comparison (in expressions):**
```typescript
{ $eq: ['$a', '$b'] }   // a == b
{ $ne: ['$a', '$b'] }   // a != b
{ $gt: ['$a', 10] }     // a > 10
{ $gte: ['$a', 10] }    // a >= 10
{ $lt: ['$a', 10] }     // a < 10
{ $lte: ['$a', 10] }    // a <= 10
```

**Logical (in expressions):**
```typescript
{ $and: [expr1, expr2] }
{ $or: [expr1, expr2] }
{ $not: expr }
```

---

## Common Patterns

### Pagination with Total Count

```typescript
const page = 1;
const pageSize = 20;

const results = await collection.aggregate([
  { $match: { status: 'published' } },
  { $facet: {
    // Get paginated data
    data: [
      { $sort: { createdAt: -1 } },
      { $skip: (page - 1) * pageSize },
      { $limit: pageSize }
    ],
    // Get total count
    totalCount: [
      { $count: 'count' }
    ]
  } }
]).toArray();

const { data, totalCount } = results[0];
const total = totalCount[0]?.count || 0;
```

### Group by Date Parts

```typescript
await collection.aggregate([
  { $addFields: {
    year: { $substr: ['$createdAt', 0, 4] },
    month: { $substr: ['$createdAt', 5, 2] }
  } },
  { $group: {
    _id: { year: '$year', month: '$month' },
    count: { $sum: 1 },
    totalRevenue: { $sum: '$amount' }
  } },
  { $sort: { '_id.year': -1, '_id.month': -1 } }
]).toArray();
```

### Top N per Group

```typescript
// Get top 3 products per category
await collection.aggregate([
  { $sort: { sales: -1 } },
  { $group: {
    _id: '$category',
    products: { $push: { name: '$name', sales: '$sales' } }
  } },
  { $project: {
    category: '$_id',
    topProducts: { $slice: ['$products', 3] }
  } }
]).toArray();
```

### Running Totals and Statistics

```typescript
await collection.aggregate([
  { $match: { orderDate: { $gte: startOfMonth } } },
  { $group: {
    _id: null,
    totalOrders: { $sum: 1 },
    totalRevenue: { $sum: '$amount' },
    averageOrderValue: { $avg: '$amount' },
    minOrder: { $min: '$amount' },
    maxOrder: { $max: '$amount' },
    uniqueCustomers: { $addToSet: '$customerId' }
  } },
  { $project: {
    _id: 0,
    totalOrders: 1,
    totalRevenue: 1,
    averageOrderValue: 1,
    minOrder: 1,
    maxOrder: 1,
    customerCount: { $size: '$uniqueCustomers' }
  } }
]).toArray();
```

### Join with Related Data

```typescript
await collection.aggregate([
  // Match orders from last 30 days
  { $match: {
    orderDate: { $gte: thirtyDaysAgo }
  } },
  // Join with customer data
  { $lookup: {
    from: 'customers',
    localField: 'customerId',
    foreignField: '_id',
    as: 'customer'
  } },
  // Unwind the customer array
  { $unwind: '$customer' },
  // Join with product details
  { $lookup: {
    from: 'products',
    localField: 'productId',
    foreignField: '_id',
    as: 'product'
  } },
  { $unwind: '$product' },
  // Project final shape
  { $project: {
    orderId: '$_id',
    amount: 1,
    orderDate: 1,
    customerName: '$customer.name',
    customerEmail: '$customer.email',
    productName: '$product.name',
    productCategory: '$product.category'
  } }
]).toArray();
```

### Conditional Aggregation

```typescript
await collection.aggregate([
  { $group: {
    _id: '$category',
    total: { $sum: 1 },
    activeCount: {
      $sum: { $cond: [{ $eq: ['$status', 'active'] }, 1, 0] }
    },
    inactiveCount: {
      $sum: { $cond: [{ $eq: ['$status', 'inactive'] }, 1, 0] }
    },
    highValueSum: {
      $sum: { $cond: [{ $gte: ['$value', 1000] }, '$value', 0] }
    }
  } }
]).toArray();
```

---

## Performance Tips

1. **Place $match early**: Filter documents as early as possible to reduce data processed by subsequent stages.

2. **Use indexes**: Ensure fields used in `$match` and `$sort` are indexed for optimal performance.

3. **Limit fields with $project**: Project only needed fields early to reduce memory usage.

4. **Combine stages when possible**: Multiple `$match` stages can often be combined.

5. **Use $limit for exploratory queries**: When testing, add `$limit` to avoid processing all documents.

6. **Order stages optimally**: Generally: $match -> $project -> $group -> $sort -> $limit

```typescript
// Optimized: $match early, project before group
await collection.aggregate([
  { $match: { status: 'active', createdAt: { $gte: lastMonth } } },
  { $project: { category: 1, amount: 1 } },
  { $group: { _id: '$category', total: { $sum: '$amount' } } },
  { $sort: { total: -1 } },
  { $limit: 10 }
]).toArray();

// Less efficient: filtering after processing
await collection.aggregate([
  { $group: { _id: '$category', total: { $sum: '$amount' } } },
  { $match: { total: { $gte: 1000 } } },  // Filter too late
  { $sort: { total: -1 } }
]).toArray();
```

---

## Limitations vs MongoDB

While MondoDB supports most common aggregation operations, there are some differences from MongoDB:

| Feature | MondoDB Support | Notes |
|---------|-----------------|-------|
| Core stages ($match, $group, etc.) | Full | Translated to optimized SQL |
| Accumulator operators | Most | $first/$last use subqueries |
| Expression operators | Common ones | See operators reference |
| $lookup pipeline | Basic | Variable binding limited |
| $graphLookup | Not supported | Graph traversal not available |
| $merge / $out | Not supported | Use separate write operations |
| $geoNear | Not supported | Use separate geo queries |
| $sample | Not supported | Use random sorting workaround |
| Window functions ($setWindowFields) | Not supported | Coming in future version |
| Array expressions ($map, $filter) | Limited | Some array ops in JS functions |

---

## Next Steps

- [Aggregation Operators Reference](/docs/reference/aggregation-operators) - Complete operator documentation
- [CRUD Operations](/docs/guides/crud) - Basic document operations
- [Indexing](/docs/guides/indexing) - Create indexes for better performance
- [Full-Text Search](/docs/guides/full-text-search) - Deep dive into FTS5
- [Vector Search](/docs/guides/vector-search) - Semantic similarity search
