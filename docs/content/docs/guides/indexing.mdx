---
title: Indexing
description: Create and manage indexes for optimal query performance in MondoDB
---

# Indexing

Indexes are essential for efficient query execution in MondoDB. This guide covers how to create, manage, and optimize indexes for your collections.

## Overview

MondoDB uses SQLite's indexing capabilities under the hood, with `json_extract` expressions to enable efficient querying on document fields. Every collection automatically has an index on the `_id` field, and you can create additional indexes to optimize your queries.

### How MondoDB Indexes Work with SQLite

When you create an index in MondoDB, it translates to a SQLite index on `json_extract` expressions:

```sql
-- A MondoDB index like { email: 1 }
-- Becomes a SQLite index like:
CREATE INDEX idx_users_email_1 ON documents (
  json_extract(data, '$.email') ASC
) WHERE collection_id = ?
```

This architecture means:
- Indexes are scoped to specific collections using `WHERE collection_id = ?`
- Field paths like `address.city` become `$.address.city` in json_extract
- Index ordering (ASC/DESC) is preserved in SQLite
- Sparse indexes add `IS NOT NULL` conditions

## Index Types

MondoDB supports several index types:

| Type | Description | Use Case |
|------|-------------|----------|
| **Single Field** | Index on one document field | Simple equality/range queries |
| **Compound** | Index on multiple fields | Multi-field queries and sorting |
| **Text** | Full-text search index (FTS5) | Text search with natural language |
| **Unique** | Ensures no duplicate values | Enforcing uniqueness constraints |
| **Sparse** | Only indexes documents with the field | Optional fields with queries |
| **TTL** | Time-To-Live for auto-expiration | Session data, logs, caches |

## Creating Indexes

### createIndex()

Use the `createIndex()` method to create an index on a collection.

```typescript
import { MongoClient } from 'mondodb'

const client = new MongoClient('mondodb://your-worker.workers.dev')
await client.connect()

const db = client.db('mydb')
const collection = db.collection('users')

// Create a single-field ascending index
await collection.createIndex({ email: 1 })

// Create a descending index
await collection.createIndex({ createdAt: -1 })
```

### Index Specification

The index specification is an object where:
- Keys are field names (including nested paths like `"address.city"`)
- Values are:
  - `1` for ascending order
  - `-1` for descending order
  - `'text'` for text indexes

```typescript
// Single field index
{ fieldName: 1 }

// Compound index
{ firstName: 1, lastName: 1 }

// Descending index
{ createdAt: -1 }

// Text index
{ description: 'text' }
```

### Index Options

The `createIndex()` method accepts an options object as the second parameter:

```typescript
interface CreateIndexOptions {
  // Custom name for the index (auto-generated if not provided)
  name?: string

  // Create a unique index
  unique?: boolean

  // Only index documents that have the indexed field
  sparse?: boolean

  // Create index in background (currently no-op, included for compatibility)
  background?: boolean

  // Partial filter expression for partial indexes
  partialFilterExpression?: Record<string, unknown>

  // TTL in seconds - documents expire after this time
  expireAfterSeconds?: number

  // Weights for text index fields (higher = more important)
  weights?: Record<string, number>

  // Default language for text index (e.g., 'english', 'none')
  default_language?: string
}
```

### createIndex() Return Value

```typescript
interface CreateIndexResult {
  ok: 1
  numIndexesBefore: number      // Number of indexes before operation
  numIndexesAfter: number       // Number of indexes after operation
  createdCollectionAutomatically: boolean  // True if collection was created
  note?: string                 // 'all indexes already exist' if duplicate
}
```

## Single Field Indexes

The most common index type, created on a single field.

```typescript
// Index on email field
await collection.createIndex({ email: 1 })

// Index on nested field
await collection.createIndex({ 'address.zipCode': 1 })

// Descending index for sorting newest first
await collection.createIndex({ createdAt: -1 })
```

**How it translates to SQLite:**

```sql
CREATE INDEX idx_users_email_1 ON documents (
  json_extract(data, '$.email') ASC
) WHERE collection_id = ?
```

**When to use:**
- Queries filtering on a single field
- Sorting by a single field
- Range queries (`$gt`, `$lt`, etc.) on a field

## Compound Indexes

Index multiple fields together for queries that filter or sort on multiple fields.

```typescript
// Compound index on firstName and lastName
await collection.createIndex({ firstName: 1, lastName: 1 })

// Compound index with mixed sort orders
await collection.createIndex({ category: 1, price: -1 })
```

**How it translates to SQLite:**

```sql
CREATE INDEX idx_products_category_1_price_-1 ON documents (
  json_extract(data, '$.category') ASC,
  json_extract(data, '$.price') DESC
) WHERE collection_id = ?
```

**When to use:**
- Queries filtering on multiple fields
- Queries that both filter and sort
- The index field order matters - put equality fields first, then range/sort fields

```typescript
// Good: equality field first, then sort field
await collection.createIndex({ status: 1, createdAt: -1 })

// Query uses this index efficiently
await collection.find({ status: 'active' }).sort({ createdAt: -1 })
```

## Unique Indexes

Enforce uniqueness constraints on a field or combination of fields.

```typescript
// Ensure email is unique across all documents
await collection.createIndex(
  { email: 1 },
  { unique: true }
)

// Compound unique index
await collection.createIndex(
  { tenantId: 1, username: 1 },
  { unique: true }
)
```

**How it translates to SQLite:**

```sql
CREATE UNIQUE INDEX idx_unique_users_email_1 ON documents (
  json_extract(data, '$.email') ASC
) WHERE collection_id = ?
```

**Behavior:**
- Insert or update operations that would create a duplicate value will fail
- `null` values are treated as equal (only one document can have `null`)

## Sparse Indexes

Only index documents that contain the indexed field. Documents without the field are excluded from the index.

```typescript
// Only index documents with an optionalField
await collection.createIndex(
  { optionalField: 1 },
  { sparse: true }
)
```

**How it translates to SQLite:**

```sql
CREATE INDEX idx_users_optionalField_1 ON documents (
  json_extract(data, '$.optionalField') ASC
) WHERE collection_id = ? AND json_extract(data, '$.optionalField') IS NOT NULL
```

**When to use:**
- Fields that exist only in some documents
- Combined with `unique` for optional unique fields

```typescript
// Optional but unique secondary email
await collection.createIndex(
  { secondaryEmail: 1 },
  { unique: true, sparse: true }
)
```

## Text Indexes

Full-text search indexes using SQLite's FTS5 (Full-Text Search 5) engine.

```typescript
// Create a text index on the description field
await collection.createIndex({ description: 'text' })

// Text index on multiple fields
await collection.createIndex({
  title: 'text',
  content: 'text'
})

// With field weights (higher = more relevant)
await collection.createIndex(
  { title: 'text', content: 'text' },
  {
    weights: { title: 10, content: 1 }
  }
)
```

### How Text Indexes Work

MondoDB creates an FTS5 virtual table for text indexing:

```sql
-- FTS5 virtual table for collection "posts"
CREATE VIRTUAL TABLE IF NOT EXISTS posts_fts USING fts5(
  _id, title, content,
  content='documents',
  content_rowid='id',
  tokenize='porter unicode61'
)
```

**Automatic sync triggers** keep the FTS5 table synchronized:
- Insert trigger: adds new documents to FTS5
- Update trigger: removes old content, adds updated content
- Delete trigger: removes document from FTS5

**Limitations:**
- Only one text index per collection
- Creating a second text index will throw an error

**Querying text indexes:**

```typescript
// Use $text operator for full-text search
const results = await collection.find({
  $text: { $search: 'mongodb database' }
}).toArray()
```

### Text Index Options

```typescript
await collection.createIndex(
  { description: 'text' },
  {
    // Language for stemming (default: 'english')
    // Uses porter stemming algorithm with unicode61 tokenizer
    default_language: 'english',

    // Use 'none' to disable stemming (unicode61 only)
    // default_language: 'none',

    // Field weights for relevance scoring
    weights: { title: 10, body: 5, tags: 1 }
  }
)
```

## TTL (Time-To-Live) Indexes

Automatically expire and delete documents after a specified time period.

```typescript
// Documents expire 24 hours after the createdAt timestamp
await collection.createIndex(
  { createdAt: 1 },
  { expireAfterSeconds: 86400 } // 24 hours
)

// Sessions expire 1 hour after lastAccess
await collection.createIndex(
  { lastAccess: 1 },
  { expireAfterSeconds: 3600 } // 1 hour
)
```

### TTL Index Implementation Details

MondoDB TTL indexes work as follows:

1. **Index creation**: A standard index is created on the date field, with TTL metadata stored
2. **Background cleanup**: Expired documents are periodically removed (default: every 60 seconds)
3. **Expiration calculation**: `document[field] + expireAfterSeconds < now()`

**Valid date field values:**
- Date objects
- ISO 8601 date strings
- Unix timestamps in milliseconds

**Important notes:**
- TTL indexes must be on a **single field** - compound TTL indexes are not supported
- Only one TTL index per collection is allowed
- Documents without the TTL field, or with invalid dates, will not expire

### TTL Cleanup Query

The cleanup process executes a query like:

```sql
DELETE FROM documents
WHERE collection_id = ?
AND json_extract(data, '$.createdAt') IS NOT NULL
AND datetime(json_extract(data, '$.createdAt')) < datetime(?)
```

**Use cases:**
- Session management
- Log rotation
- Cache expiration
- Temporary data cleanup

```typescript
// Insert a session that will auto-expire
await collection.insertOne({
  sessionId: 'abc123',
  userId: 'user1',
  createdAt: new Date(), // Will expire after expireAfterSeconds
  data: { /* session data */ }
})
```

## Listing Indexes

Retrieve all indexes on a collection.

```typescript
const indexes = await collection.listIndexes()

console.log(indexes)
// [
//   { name: '_id_', key: { _id: 1 }, v: 2 },
//   { name: 'email_1', key: { email: 1 }, v: 2, unique: true },
//   { name: 'createdAt_-1', key: { createdAt: -1 }, v: 2 }
// ]
```

### IndexInfo Structure

```typescript
interface IndexInfo {
  name: string                           // Index name
  key: Record<string, 1 | -1 | 'text'>   // Index specification
  v: number                              // Index version (always 2)
  unique?: boolean                       // Whether unique
  sparse?: boolean                       // Whether sparse
  expireAfterSeconds?: number            // TTL value if set
  textIndexVersion?: number              // Present for text indexes (value: 3)
  weights?: Record<string, number>       // Text index weights
  default_language?: string              // Text index language
  partialFilterExpression?: Document     // Partial filter if set
}
```

**Note:** The `_id_` index is always included and cannot be dropped.

## Dropping Indexes

### Drop a Specific Index

```typescript
// Drop an index by name
await collection.dropIndex('email_1')

// Returns:
// { ok: 1, nIndexesWas: 3 }
```

**Note:** You cannot drop the `_id_` index - it's always present.

```typescript
// This will throw an error
await collection.dropIndex('_id_')  // Error: cannot drop _id index
```

### Drop All Indexes

```typescript
// Drop all indexes except _id_
await collection.dropIndexes()

// Returns:
// { ok: 1, nIndexesWas: 5 }
```

**For text indexes**, dropping also removes:
- The FTS5 virtual table
- Associated triggers (insert, update, delete)

## Index Naming

### Auto-generated Names

If you don't specify a name, MondoDB generates one based on the collection name, fields, and directions:

```typescript
// Collection: users
{ email: 1 }           // name: 'users_email_1'
{ name: 1, age: -1 }   // name: 'users_name_1_age_-1'
{ bio: 'text' }        // name: 'users_bio_text'
```

**SQLite index naming convention:**
```
idx_[unique_]<collection>_<field>_<direction>[_<field>_<direction>...]
```

### Custom Names

Specify a custom name for easier management:

```typescript
await collection.createIndex(
  { email: 1 },
  { name: 'unique_email_index' }
)
```

## Query Optimization

### Index Selection

MondoDB's query optimizer selects the best index for each query. To help it:

1. **Create indexes for your query patterns:**

```typescript
// If you frequently query by status and sort by date
await collection.createIndex({ status: 1, createdAt: -1 })

// The query will use this index
await collection.find({ status: 'active' }).sort({ createdAt: -1 })
```

2. **Order compound index fields appropriately:**
   - Put equality filters first
   - Put range filters and sort fields after

```typescript
// For queries like: { category: 'books', price: { $lt: 20 } }
// Good index:
await collection.createIndex({ category: 1, price: 1 })
```

3. **Consider index selectivity:**
   - High selectivity (many unique values) = more efficient
   - Put high-selectivity fields first in compound indexes

### Covered Queries

When possible, create indexes that cover all fields in your query and projection:

```typescript
// Index covers both query and projection
await collection.createIndex({ userId: 1, status: 1 })

// This query only needs the index, not the documents
const statuses = await collection.find(
  { userId: 'user123' },
  { projection: { status: 1, _id: 0 } }
).toArray()
```

### Index Hints

MondoDB provides an `getIndexHints()` method to suggest which indexes could be used for a query:

```typescript
const indexManager = new IndexManager(storage)
const hints = indexManager.getIndexHints('users', ['email', 'status'])
// Returns: ['users_email_1', 'users_status_1']
```

## Field Path Validation

MondoDB validates field paths to prevent SQL injection and ensure data integrity:

**Valid field names:**
- Alphanumeric characters: `a-z`, `A-Z`, `0-9`
- Underscores: `_`
- Dots for nesting: `.` (e.g., `address.city`)
- Hyphens: `-`
- Dollar sign: `$` (for special fields)

**Invalid patterns:**
- Empty field names
- Null characters (`\0`)
- Consecutive dots (`..`)
- Leading or trailing dots

```typescript
// Valid
await collection.createIndex({ 'user.profile.name': 1 })

// Invalid - will throw error
await collection.createIndex({ '..invalid': 1 })
```

## Performance Tips

### Do:

- **Create indexes for frequently executed queries** - Analyze your query patterns
- **Use compound indexes for multi-field queries** - They're more efficient than multiple single-field indexes
- **Put high-selectivity fields first** - Fields with many unique values should come first
- **Use sparse indexes for optional fields** - Reduces index size and improves performance
- **Use TTL indexes for auto-expiring data** - Cleaner than manual deletion
- **Monitor index usage** - Remove unused indexes

### Don't:

- **Create too many indexes** - Each index has write overhead (inserts/updates are slower)
- **Create indexes on low-selectivity fields alone** - Boolean fields or fields with few unique values
- **Create multiple text indexes on the same collection** - Only one is allowed
- **Create compound TTL indexes** - Not supported
- **Index every field** - Focus on actual query patterns

### Index Size Considerations

Since MondoDB stores indexes in SQLite:
- Indexes consume additional storage in the SQLite database
- Large text indexes (FTS5) can be significant
- Consider partial indexes for large collections

## Complete Example

```typescript
import { MongoClient } from 'mondodb'

async function setupIndexes() {
  const client = new MongoClient('mondodb://your-worker.workers.dev')
  await client.connect()

  const db = client.db('myapp')
  const users = db.collection('users')
  const sessions = db.collection('sessions')
  const posts = db.collection('posts')

  // Unique email index
  await users.createIndex(
    { email: 1 },
    { unique: true, name: 'unique_email' }
  )

  // Compound index for user lookups
  await users.createIndex(
    { status: 1, createdAt: -1 },
    { name: 'status_created' }
  )

  // Sparse index for optional phone number
  await users.createIndex(
    { phone: 1 },
    { sparse: true, unique: true, name: 'unique_phone' }
  )

  // TTL index for session expiration (1 hour)
  await sessions.createIndex(
    { lastAccess: 1 },
    { expireAfterSeconds: 3600, name: 'session_ttl' }
  )

  // Text index for post search
  await posts.createIndex(
    { title: 'text', content: 'text' },
    {
      weights: { title: 10, content: 1 },
      name: 'post_search'
    }
  )

  // Compound index for post queries
  await posts.createIndex(
    { authorId: 1, publishedAt: -1 },
    { name: 'author_published' }
  )

  // Sparse index for featured posts
  await posts.createIndex(
    { featuredAt: 1 },
    { sparse: true, name: 'featured_posts' }
  )

  // List all indexes
  console.log('Users indexes:', await users.listIndexes())
  console.log('Sessions indexes:', await sessions.listIndexes())
  console.log('Posts indexes:', await posts.listIndexes())

  await client.close()
}
```

## Troubleshooting

### "Collection already has a text index"

Only one text index is allowed per collection. Drop the existing text index before creating a new one:

```typescript
await collection.dropIndex('old_text_index_name')
await collection.createIndex({ newField: 'text' })
```

### "TTL indexes must be on a single field"

Compound TTL indexes are not supported. Create a TTL index on a single date field:

```typescript
// Wrong - compound TTL
await collection.createIndex(
  { category: 1, expiresAt: 1 },
  { expireAfterSeconds: 3600 }
)

// Correct - single field TTL
await collection.createIndex(
  { expiresAt: 1 },
  { expireAfterSeconds: 3600 }
)
```

### "Invalid field name"

Ensure field names follow the validation rules (alphanumeric, underscores, dots for nesting):

```typescript
// Invalid
await collection.createIndex({ 'field with spaces': 1 })

// Valid
await collection.createIndex({ 'field_with_underscores': 1 })
```

## Related

- [CRUD Operations](/docs/guides/crud) - Basic document operations
- [Aggregation](/docs/guides/aggregation) - Data processing pipelines
- [API Reference: Collection](/docs/api-reference/collection) - Full API documentation
