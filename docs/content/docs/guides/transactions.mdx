---
title: Transactions
description: Use multi-document transactions for atomic operations across documents and collections
---

# Transactions

MondoDB supports multi-document transactions, providing ACID guarantees for operations that need to be atomic across multiple documents or collections. Transactions ensure that either all operations succeed together, or none of them take effect.

## Overview

Transactions in MondoDB work through sessions. A session tracks the state of a transaction and ensures that all operations within the transaction are executed atomically.

### How Transactions Work in MondoDB

MondoDB maps MongoDB transaction semantics to SQLite transactions:

| MongoDB Operation | SQLite Equivalent |
|------------------|-------------------|
| `startTransaction()` | `BEGIN IMMEDIATE TRANSACTION` |
| `commitTransaction()` | `COMMIT` |
| `abortTransaction()` | `ROLLBACK` |

**Key architectural details:**
- In Durable Objects mode, transactions use SQLite's native transaction support via `transactionSync()`
- In URI/in-memory mode, transactions use snapshot-based rollback for data consistency
- Sessions generate unique IDs using ObjectId for tracking and debugging

## Starting a Session

Use `startSession()` on the MongoClient to create a new session:

```typescript
import { MongoClient } from 'mondodb'

const client = new MongoClient('mondodb://localhost:27017')
await client.connect()

// Create a session
const session = client.startSession()

// Use the session for operations...

// Always end the session when done
await session.endSession()
```

### Session Options

You can configure default transaction options when creating a session:

```typescript
const session = client.startSession({
  defaultTransactionOptions: {
    readConcern: { level: 'majority' },
    writeConcern: { w: 'majority' },
    maxCommitTimeMS: 5000
  },
  // Enable causal consistency (for ordering guarantees)
  causalConsistency: true,
  // Enable snapshot reads
  snapshot: false
})
```

### ClientSessionOptions Interface

```typescript
interface ClientSessionOptions {
  /** Default options for transactions started in this session */
  defaultTransactionOptions?: TransactionOptions

  /** Enable causal consistency */
  causalConsistency?: boolean

  /** Enable snapshot reads */
  snapshot?: boolean
}
```

## Transaction Lifecycle

A transaction goes through several states during its lifecycle:

| State | Description |
|-------|-------------|
| `none` | No transaction active |
| `starting` | Transaction started but no operations executed yet |
| `in_progress` | Transaction has operations in flight |
| `committed` | Transaction successfully committed |
| `aborted` | Transaction was rolled back |

```
none -> starting -> in_progress -> committed
                               \-> aborted
```

When the first operation is executed within a transaction, the state automatically transitions from `starting` to `in_progress`.

## Manual Transaction Control

For full control over transaction behavior, use manual transaction management:

```typescript
const session = client.startSession()

try {
  // Start the transaction
  session.startTransaction()

  // Perform operations within the transaction
  await collection.insertOne({ name: 'Alice', balance: 1000 }, { session })
  await collection.updateOne(
    { name: 'Bob' },
    { $inc: { balance: -100 } },
    { session }
  )

  // Commit the transaction
  await session.commitTransaction()
  console.log('Transaction committed successfully')
} catch (error) {
  // If an error occurs, abort the transaction
  await session.abortTransaction()
  console.error('Transaction aborted:', error)
  throw error
} finally {
  // Always end the session
  await session.endSession()
}
```

### Session Properties

The session object provides several useful properties:

```typescript
// Check if currently in a transaction
if (session.inTransaction) {
  console.log('Transaction is active')
}

// Get the current transaction state
console.log(session.transactionState)
// 'none' | 'starting' | 'in_progress' | 'committed' | 'aborted'

// Get the current transaction options
const options = session.transactionOptions
// { readConcern, writeConcern, maxCommitTimeMS }

// Get the current transaction number (increments with each new transaction)
console.log(session.transactionNumber) // 1, 2, 3...

// Check if session has ended
if (session.hasEnded) {
  console.log('Session has ended')
}

// Get the unique session ID
console.log(session.id.toHexString()) // e.g., "507f1f77bcf86cd799439011"
```

### Session Methods

```typescript
// Start a new transaction
session.startTransaction(options?: TransactionOptions): void

// Commit the current transaction
await session.commitTransaction(): Promise<void>

// Abort (rollback) the current transaction
await session.abortTransaction(): Promise<void>

// End the session (aborts any active transaction)
await session.endSession(): Promise<void>

// Execute callback with automatic commit/abort
await session.withTransaction<T>(
  callback: (session) => Promise<T>,
  options?: TransactionOptions
): Promise<T>
```

## Using withTransaction Helper

The `withTransaction()` helper provides automatic commit and abort handling, plus built-in retry logic for transient errors:

```typescript
const session = client.startSession()

try {
  const result = await session.withTransaction(async (sess) => {
    const accounts = db.collection('accounts')

    // Transfer funds between accounts
    await accounts.updateOne(
      { userId: 'alice' },
      { $inc: { balance: -100 } },
      { session: sess }
    )

    await accounts.updateOne(
      { userId: 'bob' },
      { $inc: { balance: 100 } },
      { session: sess }
    )

    // Return a value from the transaction
    return { transferred: 100 }
  })

  console.log('Transfer complete:', result)
} finally {
  await session.endSession()
}
```

### Automatic Retry Logic

`withTransaction()` automatically retries on transient transaction errors. The retry behavior:

1. **Detection**: Checks if the error has the `TransientTransactionError` label
2. **Abort**: Aborts the current transaction attempt
3. **Wait**: Pauses for 100ms before retrying
4. **Retry**: Starts a new transaction and re-executes the callback
5. **Limit**: Continues retrying up to 120 attempts (matching MongoDB's default)

```typescript
await session.withTransaction(async (sess) => {
  // If this throws a TransientTransactionError,
  // the entire callback will be retried automatically
  await collection.updateOne(
    { _id: docId },
    { $set: { status: 'processed' } },
    { session: sess }
  )
})
```

### withTransaction Options

```typescript
await session.withTransaction(
  async (sess) => {
    // ... operations
  },
  {
    readConcern: { level: 'snapshot' },
    writeConcern: { w: 'majority' },
    maxCommitTimeMS: 10000
  }
)
```

## Transaction Options

### Read Concern

Read concern controls the consistency and isolation properties of data reads:

```typescript
session.startTransaction({
  readConcern: { level: 'local' }      // Read from local replica (fastest)
})

session.startTransaction({
  readConcern: { level: 'majority' }   // Read data acknowledged by majority
})

session.startTransaction({
  readConcern: { level: 'snapshot' }   // Point-in-time snapshot isolation
})
```

| Level | Description |
|-------|-------------|
| `local` | Returns the most recent data available on the local node |
| `available` | Returns data from the instance with no guarantee of durability |
| `majority` | Returns data that has been acknowledged by a majority of replica set members |
| `linearizable` | Returns data that reflects all successful writes prior to the read |
| `snapshot` | Returns data from a snapshot of the data at a specific point in time |

### Write Concern

Write concern controls the acknowledgment of write operations:

```typescript
session.startTransaction({
  writeConcern: { w: 1 }               // Acknowledge from primary only
})

session.startTransaction({
  writeConcern: { w: 'majority' }      // Acknowledge from majority of nodes
})

session.startTransaction({
  writeConcern: {
    w: 'majority',
    wtimeoutMS: 5000,                  // Timeout for write acknowledgment
    journal: true                       // Wait for journal write
  }
})
```

### Max Commit Time

Set a timeout for the commit operation:

```typescript
session.startTransaction({
  maxCommitTimeMS: 10000  // 10 second timeout for commit
})
```

## Transaction Scope in Durable Objects

Understanding transaction scope is important when using MondoDB with Cloudflare Durable Objects:

### Single Durable Object Scope

Transactions are scoped to a **single Durable Object instance**:

```typescript
// This works - same database (same Durable Object)
await session.withTransaction(async (sess) => {
  const users = db.collection('users')
  const orders = db.collection('orders')

  // Both collections are in the same database/Durable Object
  await users.updateOne({ _id: userId }, { $inc: { orderCount: 1 } }, { session: sess })
  await orders.insertOne({ userId, items: [...] }, { session: sess })
})
```

### Cross-Database Limitations

Cross-database transactions are **not supported** because different databases map to different Durable Objects:

```typescript
// This will NOT work as expected
await session.withTransaction(async (sess) => {
  const db1 = client.db('database1')
  const db2 = client.db('database2')  // Different Durable Object!

  // These operations are NOT atomic together
  await db1.collection('users').updateOne({...}, {...}, { session: sess })
  await db2.collection('logs').insertOne({...}, { session: sess })
})
```

### SQLite Transaction Behavior

In Durable Objects mode, MondoDB uses SQLite's `transactionSync()`:

```typescript
// Internally, bulk operations use transactionSync
const insertedIds = this.state.storage.transactionSync(() => {
  const ids: string[] = []
  for (const document of documents) {
    // ... insert each document
    ids.push(docId)
  }
  return ids
})
// If any insert fails, all are rolled back
```

The SQL transaction mode used is `BEGIN IMMEDIATE TRANSACTION`, which:
- Acquires a write lock immediately
- Prevents other writers from modifying data during the transaction
- Provides serializable isolation

## Practical Examples

### Bank Transfer

A classic example of when transactions are essential - transferring money between accounts:

```typescript
interface Account {
  _id?: ObjectId
  userId: string
  balance: number
  currency: string
}

interface TransferLog {
  _id?: ObjectId
  from: string
  to: string
  amount: number
  timestamp: Date
  status: 'completed' | 'failed'
}

async function transferFunds(
  fromUserId: string,
  toUserId: string,
  amount: number
): Promise<{ success: boolean; transferId?: string }> {
  const session = client.startSession()

  try {
    const result = await session.withTransaction(async (sess) => {
      const accounts = db.collection<Account>('accounts')
      const transfers = db.collection<TransferLog>('transfers')

      // Step 1: Verify source account has sufficient funds
      const sourceAccount = await accounts.findOne(
        { userId: fromUserId },
        { session: sess }
      )

      if (!sourceAccount) {
        throw new Error(`Account not found: ${fromUserId}`)
      }

      if (sourceAccount.balance < amount) {
        throw new Error(
          `Insufficient funds: ${sourceAccount.balance} < ${amount}`
        )
      }

      // Step 2: Verify destination account exists
      const destAccount = await accounts.findOne(
        { userId: toUserId },
        { session: sess }
      )

      if (!destAccount) {
        throw new Error(`Destination account not found: ${toUserId}`)
      }

      // Step 3: Debit source account
      await accounts.updateOne(
        { userId: fromUserId },
        {
          $inc: { balance: -amount },
          $set: { lastModified: new Date() }
        },
        { session: sess }
      )

      // Step 4: Credit destination account
      await accounts.updateOne(
        { userId: toUserId },
        {
          $inc: { balance: amount },
          $set: { lastModified: new Date() }
        },
        { session: sess }
      )

      // Step 5: Record the transfer in audit log
      const transferResult = await transfers.insertOne({
        from: fromUserId,
        to: toUserId,
        amount,
        timestamp: new Date(),
        status: 'completed'
      }, { session: sess })

      return { transferId: transferResult.insertedId }
    })

    console.log(`Transferred $${amount} from ${fromUserId} to ${toUserId}`)
    return { success: true, transferId: result.transferId }
  } catch (error) {
    console.error('Transfer failed:', error)
    return { success: false }
  } finally {
    await session.endSession()
  }
}
```

### Order Processing with Inventory

Managing inventory across orders requires atomic operations to prevent overselling:

```typescript
interface Product {
  _id?: ObjectId
  sku: string
  name: string
  price: number
  quantity: number      // Available stock
  reserved: number      // Reserved for pending orders
}

interface Order {
  _id?: ObjectId
  orderId: string
  customerId: string
  items: Array<{ sku: string; quantity: number; price: number }>
  status: 'pending' | 'reserved' | 'fulfilled' | 'cancelled'
  total: number
  createdAt: Date
  updatedAt: Date
}

async function createOrder(
  customerId: string,
  items: Array<{ sku: string; quantity: number }>
): Promise<Order> {
  const session = client.startSession()

  try {
    const order = await session.withTransaction(async (sess) => {
      const inventory = db.collection<Product>('inventory')
      const orders = db.collection<Order>('orders')

      const orderItems: Order['items'] = []
      let total = 0

      // Step 1: Validate and reserve inventory for each item
      for (const item of items) {
        const product = await inventory.findOne(
          { sku: item.sku },
          { session: sess }
        )

        if (!product) {
          throw new Error(`Product not found: ${item.sku}`)
        }

        const available = product.quantity - product.reserved
        if (available < item.quantity) {
          throw new Error(
            `Insufficient inventory for ${item.sku}: ` +
            `${available} available, ${item.quantity} requested`
          )
        }

        // Reserve the inventory
        await inventory.updateOne(
          { sku: item.sku },
          { $inc: { reserved: item.quantity } },
          { session: sess }
        )

        orderItems.push({
          sku: item.sku,
          quantity: item.quantity,
          price: product.price
        })
        total += product.price * item.quantity
      }

      // Step 2: Create the order
      const orderId = `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
      const newOrder: Order = {
        orderId,
        customerId,
        items: orderItems,
        status: 'reserved',
        total,
        createdAt: new Date(),
        updatedAt: new Date()
      }

      await orders.insertOne(newOrder, { session: sess })

      return newOrder
    })

    return order
  } finally {
    await session.endSession()
  }
}

async function fulfillOrder(orderId: string): Promise<void> {
  const session = client.startSession()

  try {
    await session.withTransaction(async (sess) => {
      const inventory = db.collection<Product>('inventory')
      const orders = db.collection<Order>('orders')

      // Find the order
      const order = await orders.findOne(
        { orderId, status: 'reserved' },
        { session: sess }
      )

      if (!order) {
        throw new Error(`Order not found or not in reserved status: ${orderId}`)
      }

      // Deduct inventory for each item
      for (const item of order.items) {
        await inventory.updateOne(
          { sku: item.sku },
          {
            $inc: {
              quantity: -item.quantity,   // Reduce actual stock
              reserved: -item.quantity    // Clear reservation
            }
          },
          { session: sess }
        )
      }

      // Update order status
      await orders.updateOne(
        { orderId },
        {
          $set: {
            status: 'fulfilled',
            updatedAt: new Date()
          }
        },
        { session: sess }
      )
    })
  } finally {
    await session.endSession()
  }
}

async function cancelOrder(orderId: string): Promise<void> {
  const session = client.startSession()

  try {
    await session.withTransaction(async (sess) => {
      const inventory = db.collection<Product>('inventory')
      const orders = db.collection<Order>('orders')

      const order = await orders.findOne(
        { orderId, status: 'reserved' },
        { session: sess }
      )

      if (!order) {
        throw new Error(`Order not found or cannot be cancelled: ${orderId}`)
      }

      // Release reserved inventory
      for (const item of order.items) {
        await inventory.updateOne(
          { sku: item.sku },
          { $inc: { reserved: -item.quantity } },
          { session: sess }
        )
      }

      // Update order status
      await orders.updateOne(
        { orderId },
        {
          $set: {
            status: 'cancelled',
            updatedAt: new Date()
          }
        },
        { session: sess }
      )
    })
  } finally {
    await session.endSession()
  }
}
```

### Multi-Collection User Profile Update

Updating related documents across multiple collections atomically:

```typescript
interface User {
  _id?: ObjectId
  email: string
  profile: {
    name: string
    displayName: string
    bio: string
    avatar?: string
  }
  updatedAt: Date
}

interface Post {
  _id?: ObjectId
  authorId: string
  authorName: string      // Denormalized for display
  authorAvatar?: string   // Denormalized for display
  title: string
  content: string
}

interface Comment {
  _id?: ObjectId
  authorId: string
  authorName: string      // Denormalized for display
  postId: string
  text: string
}

async function updateUserProfile(
  userId: string,
  updates: { name?: string; bio?: string; avatar?: string }
): Promise<void> {
  const session = client.startSession()

  try {
    await session.withTransaction(async (sess) => {
      const users = db.collection<User>('users')
      const posts = db.collection<Post>('posts')
      const comments = db.collection<Comment>('comments')

      // Build the update object
      const userUpdate: Record<string, unknown> = {
        updatedAt: new Date()
      }
      if (updates.name) userUpdate['profile.name'] = updates.name
      if (updates.bio) userUpdate['profile.bio'] = updates.bio
      if (updates.avatar) userUpdate['profile.avatar'] = updates.avatar

      // Step 1: Update the user document
      const result = await users.updateOne(
        { _id: userId },
        { $set: userUpdate },
        { session: sess }
      )

      if (result.matchedCount === 0) {
        throw new Error(`User not found: ${userId}`)
      }

      // Step 2: Update denormalized data in posts (if name changed)
      if (updates.name) {
        const postUpdate: Record<string, unknown> = { authorName: updates.name }
        if (updates.avatar) postUpdate.authorAvatar = updates.avatar

        await posts.updateMany(
          { authorId: userId },
          { $set: postUpdate },
          { session: sess }
        )

        // Step 3: Update denormalized data in comments
        await comments.updateMany(
          { authorId: userId },
          { $set: { authorName: updates.name } },
          { session: sess }
        )
      }
    })

    console.log(`Profile updated for user ${userId}`)
  } finally {
    await session.endSession()
  }
}
```

## Error Handling

### Handling Transaction Errors

```typescript
const session = client.startSession()

try {
  await session.withTransaction(async (sess) => {
    await collection.insertOne({ name: 'Test' }, { session: sess })
  })
} catch (error) {
  // Check for specific error types
  if (error.message.includes('Insufficient')) {
    console.error('Business logic error:', error.message)
  } else if (error.hasErrorLabel?.('TransientTransactionError')) {
    console.error('Transient error - would have been retried:', error.message)
  } else if (error.hasErrorLabel?.('UnknownTransactionCommitResult')) {
    console.error('Commit result unknown - may need manual verification')
  } else {
    console.error('Transaction failed:', error)
  }
  throw error
} finally {
  await session.endSession()
}
```

### Transaction Validation Errors

Certain operations are not allowed within transactions:

```typescript
// Cannot start a transaction when one is already active
const session = client.startSession()
session.startTransaction()
session.startTransaction() // Error: Transaction already in progress
```

```typescript
// Cannot commit without starting a transaction
const session = client.startSession()
await session.commitTransaction() // Error: No transaction started
```

```typescript
// Cannot use an ended session
const session = client.startSession()
await session.endSession()
session.startTransaction() // Error: Cannot start transaction on ended session
```

### Error Recovery Pattern

```typescript
async function robustTransaction<T>(
  client: MongoClient,
  operation: (session: ClientSession) => Promise<T>,
  maxRetries: number = 3
): Promise<T> {
  let lastError: Error | null = null

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    const session = client.startSession()

    try {
      const result = await session.withTransaction(async (sess) => {
        return await operation(sess)
      })
      return result
    } catch (error) {
      lastError = error as Error
      console.error(`Attempt ${attempt} failed:`, error)

      // Don't retry business logic errors
      if (error.message.includes('not found') ||
          error.message.includes('insufficient')) {
        throw error
      }

      // Wait before retrying (exponential backoff)
      if (attempt < maxRetries) {
        await new Promise(r => setTimeout(r, Math.pow(2, attempt) * 100))
      }
    } finally {
      await session.endSession()
    }
  }

  throw lastError
}

// Usage
await robustTransaction(client, async (session) => {
  await collection.updateOne(
    { _id: 'doc1' },
    { $set: { status: 'processed' } },
    { session }
  )
})
```

## Best Practices

### 1. Keep Transactions Short

Long-running transactions can impact performance and increase the chance of conflicts:

```typescript
// Good: Short, focused transaction
await session.withTransaction(async (sess) => {
  await accounts.updateOne({ _id: from }, { $inc: { balance: -amount } }, { session: sess })
  await accounts.updateOne({ _id: to }, { $inc: { balance: amount } }, { session: sess })
})

// Bad: Long transaction with external calls
await session.withTransaction(async (sess) => {
  await accounts.updateOne({ _id: from }, { $inc: { balance: -amount } }, { session: sess })
  await sendEmail(user.email)  // External call - can't be rolled back!
  await accounts.updateOne({ _id: to }, { $inc: { balance: amount } }, { session: sess })
})
```

### 2. Always Use try/finally

Ensure proper cleanup even if errors occur:

```typescript
const session = client.startSession()
try {
  await session.withTransaction(async (sess) => {
    // ... operations
  })
} finally {
  await session.endSession()  // Always called
}
```

### 3. Pass Session to All Operations

Every operation within a transaction must include the session option:

```typescript
await session.withTransaction(async (sess) => {
  // Correct: session passed to all operations
  await collection.findOne({ _id: 1 }, { session: sess })
  await collection.updateOne({ _id: 1 }, { $set: { x: 1 } }, { session: sess })
  await collection.insertOne({ _id: 2 }, { session: sess })

  // Wrong: missing session - this operation won't be part of the transaction
  // await collection.deleteOne({ _id: 3 })
})
```

### 4. Validate Before Modifying

Check preconditions before making changes:

```typescript
await session.withTransaction(async (sess) => {
  // Validate first
  const account = await accounts.findOne({ _id: userId }, { session: sess })
  if (!account || account.balance < amount) {
    throw new Error('Insufficient funds')
  }

  // Then modify
  await accounts.updateOne(
    { _id: userId },
    { $inc: { balance: -amount } },
    { session: sess }
  )
})
```

### 5. Avoid Side Effects

Don't perform external operations inside transactions since they cannot be rolled back:

```typescript
// Bad: External operations in transaction
await session.withTransaction(async (sess) => {
  await orders.insertOne(order, { session: sess })
  await sendConfirmationEmail(order)  // Can't rollback if commit fails!
  await inventory.updateOne({...}, {...}, { session: sess })
})

// Good: External operations after commit
await session.withTransaction(async (sess) => {
  await orders.insertOne(order, { session: sess })
  await inventory.updateOne({...}, {...}, { session: sess })
})
// Only send email after successful commit
await sendConfirmationEmail(order)
```

### 6. Use withTransaction()

Prefer `withTransaction()` over manual transaction management:

```typescript
// Recommended: withTransaction handles retries and cleanup
await session.withTransaction(async (sess) => {
  // ... operations
})

// Manual: More error-prone, no automatic retries
session.startTransaction()
try {
  // ... operations
  await session.commitTransaction()
} catch (error) {
  await session.abortTransaction()
  throw error
}
```

## Limitations

### Current Limitations in MondoDB

1. **Single Durable Object scope**: Transactions are scoped to a single Durable Object instance
2. **Cross-database transactions not supported**: Different databases map to different Durable Objects
3. **Maximum execution time**: Transactions have a timeout based on Durable Object limits
4. **Read/write concern semantics**: While the API accepts read/write concerns, SQLite provides serializable isolation by default

### Differences from MongoDB

| Feature | MongoDB | MondoDB |
|---------|---------|---------|
| Multi-document transactions | Across replica sets | Single Durable Object |
| Distributed transactions | Supported | Not supported |
| Sharded transactions | Supported | N/A |
| Read concern: linearizable | Supported | Maps to local |
| Write concern: w > 1 | Supported | Maps to w: 1 |

## Session ID Uniqueness

Each session is assigned a unique identifier that can be used for tracking and debugging:

```typescript
const session1 = client.startSession()
const session2 = client.startSession()

// Each session has a unique ID (12-byte ObjectId as hex string)
console.log(session1.id.toHexString()) // e.g., "507f1f77bcf86cd799439011"
console.log(session2.id.toHexString()) // e.g., "507f1f77bcf86cd799439012"

// Useful for logging and debugging
console.log(`[Session ${session1.id}] Starting transaction...`)
console.log(`[Session ${session1.id}] Transaction #${session1.transactionNumber}`)
```

## Next Steps

- Learn about [CRUD Operations](/docs/guides/crud)
- Explore [Aggregation Pipelines](/docs/guides/aggregation)
- Understand [Indexing](/docs/guides/indexing) for performance
